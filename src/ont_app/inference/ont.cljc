(ns ont-app.inference.ont
  (:require
   ;;
   [ont-app.igraph.core :as igraph :refer [add]]
   [ont-app.igraph.graph :as g :refer [make-graph]]
   [ont-app.igraph-vocabulary.core :as igv]
   [ont-app.vocabulary.core :as voc]
   )
  )
(voc/cljc-put-ns-meta!
 'ont-app.validation.ont
 {
  :vann/preferredNamespacePrefix "infer"
  :vann/preferredNamespaceUri "http://rdf.naturallexicon.org/inference/ont#"
  })



(def ontology-ref (atom (make-graph)))


(defn update-ontology [to-add]
  (swap! ontology-ref add to-add))


(update-ontology
 [[:infer/Rule
   :rdf/type :proto/Prototype
   :rdfs/comment "Refers to an associative pattern in a model"
   :proto/hasParameter :infer/antecedent
   :proto/hasParameter :infer/consequent
   ]
  [:infer/antecedent
   :rdf/type :proto/Property
   :proto/aggregation :proto/Exclusive
   :rdfs/comment "Asserts a query pattern which may match the current state of some model, triggering a consequent when all variables are bound."
   ]
  [:infer/consequent
   :rdf/type :proto/Property
   :proto/aggregation :proto/Exclusive
   :rdfs/domain :infer/Rule
   :rdfs/range :infer/DeltaSpec
   :rdfs/comment "Asserts a set of delta specifications of the form [<:add/:subtract> <s> <p> <o>] implied if all variables within <antecedent> are bound. May also be a ConsequentFunction"
   ]
  [:infer/consequentFn
   :rdfs/subPropertyOf :infer/consequent
   :proto/aggrregation :proto/Exclusive
   :rdfs/range :infer/ConsequentFunction
   :rdfs/comment "Asserts the ID of a function [rules model bmap] -> <DeltaSpec>
Where
<bmap> is the antecedent binding of some rule
<DeltaSpec> := [<delta>,...]
<deltal> := [<op> <s> <p> <o>]
"
   ]
  [:infer/ConsequentFunction
   :proto/elaborates :proto/Function
   :proto/argumentList [:?rules :?model :?deltas :?antecedentBinding]
   :proto/returns :infer/DeltaSpec
   :rdfs/comment "
A reducing function which collects <deltas>  for the model implied by the rule. 
Where
<rules> is the rule base, which may contain declarative constructs used by the function
<model> is the model to which the rule is applied
<deltas> := [<delta>, ...]
<antecedentBinding> is a binding map, the result of the antecedent query and any special bindings.
<delta> := [<op> <s> <p> <o>]
"
   ]
  
  [:infer/memberConsequent
   :proto/aggregation :proto/Occlusive
   :rdfs/domain :infer/ConsequentFunction
   :rdfs/range :infer/DeltaSpec
   :rdfs/comment "Provides a DeltaSpec with variables to be mapped to a binding map applied to each member of some collection which the consequent function is aggregating over. "
   ]
  [:infer/DeltaSpec :proto/elaborates :igraph/Vector
   :rdfs/comment "A vector of the form [[:add/subtract <s> <p> <o>], ...]"
   ;; TODO: integrate with clojure.spec.
   ]
  [:infer/memberBindingFn
   :proto/elaborates :igraph/Function
   :rdfs/domain :infer/ConsequentFunction
   :igraph/argumentList [:?rules :?model :?bmap :?item] ;; -> <bmap'>
   :rdfs/comment "A function which given a binding map and an item to be agregated by a Consequent Function will update the bmap to make it appropriate for the member consequent."
   ]
  [:infer/test
   :rdf/type :proto/Property
   :rdfs/domain :infer/Rule
   :rdfs/range :infer/TestFunction
   :proto/aggregation :proto/Occlusive
   :rdfs/comment "<rule> test <fn-kwi> 
<fn-wki> compiledAs <test-fn>
Asserts that <test-fn> must be truthy for the rule to execute
Where
<test-fn> := (fn [model bmap]...)-> truthy "
   ]
  [:infer/TestFunction
   :proto/elaborates :proto/Function
   :proto/argumentList [:?model :?bmap]
   :rdfs/comment "<rule> test <test-fn-kwi>
<test-fn-kwi> compiledAs (fn [model bmap]...) -> true 
iff <bmap> complies with the proper conditions for inferring the consequent of <rule>
Where
<bmap> := {<var> <value>, ...} for the antecedent of <rule> and any special bindings.
"
   ]
 [:infer/specialBindings
   :rdfs/domain :infer/Rule
   :rdfs/range :igraph/Vector
   :proto/aggregation :proto/Inclusive
   :rdfs/comment "
<rule> :infer/specialBindings [:?myVar, ...], specifying order of execution
<rule> :?myVar  <SpecialBindingFunction>
<SpecialBindingFunction> :igraph/compiledAs (fn [model antecedent-binding] ...)

Asserts that the consequent of some rule relies on a minted
identifier :?myVar, whose value is generated by :?myVar's binding, a
function which takes the current model and <antecedent-binding> as its
only argument.

"
  ]
  [:infer/SpecialBindingFunction
   :proto/elaborates :proto/Function
   :proto/argumentList [:?model :?antecedentBinding]
   :rdfs/comment "
A function (fn[model antecedentbinding]..) -> <binding value>
Where
<model> is the model to which the rule is being applied.
<antecedentBinding> :=[<var> <value>, ...] derived by querying the antecedent 
  of the rule
<binding value> a value to be bound to some special binding in the rule, added 
  to <bmap> and applied to the consequent."
   ]
  ])

(def ontology @ontology-ref)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; VALIDATION 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def validator-ref (atom (make-graph)))

(defn update-validator [to-add]
  (swap! validator-ref add to-add)
  )

^:BindingTest
(defn check-param [subject-var param model bmap]
  "Returns <bmap> annotated with MissingParameter status if <subject var> is not found in <model>
Where
<bmap> is a binding returned by the :CheckRuleParameters query.
<subject-var> is typically 'antecedent' or 'consequent'"
  (let [rule (subject-var bmap)]
    (if (model (bmap subject-var) param)
      (assoc bmap :validation/status :validation/Success)
      ;; else
      (assoc bmap
             :validation/status :infer/MissingParameter
             ::subject-var subject-var
             ::parameter param
             ::keys (keys (model rule))
             ))))

(update-validator
 [[:infer/CheckRuleParameters
   :rdf/type :validation/Test
   :validation/query
   [[:?rule :rdf/type :infer/Rule]
    ]
   :validation/bindingTest :infer/ShouldHaveAntecedent
   :validation/bindingTest :infer/ShouldHaveConsequent
   :rdfs/comment "Each rule should have an antecedent and a consequent"
   ]
  [:infer/ShouldHaveAntecedent
   :igraph/compiledAs
   (partial check-param :?rule :infer/antecedent)
   :validation/commentTemplate
   "Rule {{?rule}} Does not have an antecedent."
   ]
  [:infer/ShouldHaveConsequent
   :igraph/compiledAs
   (partial check-param :?rule :infer/consequent)
   :validation/commentTemplate
   "Rule {{?rule}} Does not have a consequent."
   ]  
  ])

(def validator @validator-ref)
